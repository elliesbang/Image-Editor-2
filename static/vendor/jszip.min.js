/*! Lightweight JSZip-compatible builder for Elliesbang demo */
(function () {
  if (typeof TextEncoder === 'undefined') {
    console.warn('TextEncoder is required for the lightweight JSZip build.');
    return;
  }

  const encoder = new TextEncoder();
  const crcTable = new Uint32Array(256);
  (function initCrcTable() {
    for (let i = 0; i < 256; i += 1) {
      let c = i;
      for (let j = 0; j < 8; j += 1) {
        c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
      }
      crcTable[i] = c >>> 0;
    }
  })();

  function sanitize(path) {
    return path.replace(/\\+/g, '/').replace(/^\/+/g, '').replace(/\0/g, '');
  }

  function toBytes(input) {
    if (typeof input === 'string') return encoder.encode(input);
    if (input instanceof Uint8Array) return input;
    if (input instanceof ArrayBuffer) return new Uint8Array(input);
    throw new Error('Unsupported data type');
  }

  function fromBase64(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i += 1) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  function crc32(bytes) {
    let crc = 0xffffffff;
    for (let i = 0; i < bytes.length; i += 1) {
      crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xff];
    }
    return (crc ^ 0xffffffff) >>> 0;
  }

  function dosTime() {
    const now = new Date();
    return {
      time: ((now.getHours() << 11) | (now.getMinutes() << 5) | Math.floor(now.getSeconds() / 2)) & 0xffff,
      date: (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate()) & 0xffff
    };
  }

  function createLocalHeader(entry) {
    const buffer = new Uint8Array(30);
    const view = new DataView(buffer.buffer);
    view.setUint32(0, 0x04034b50, true);
    view.setUint16(4, 20, true);
    view.setUint16(6, 0, true);
    view.setUint16(8, 0, true);
    view.setUint16(10, entry.time, true);
    view.setUint16(12, entry.date, true);
    view.setUint32(14, entry.crc, true);
    view.setUint32(18, entry.size, true);
    view.setUint32(22, entry.size, true);
    view.setUint16(26, entry.nameBytes.length, true);
    view.setUint16(28, 0, true);
    return buffer;
  }

  function createCentralHeader(entry, offset) {
    const buffer = new Uint8Array(46);
    const view = new DataView(buffer.buffer);
    view.setUint32(0, 0x02014b50, true);
    view.setUint16(4, 20, true);
    view.setUint16(6, 20, true);
    view.setUint16(8, 0, true);
    view.setUint16(10, 0, true);
    view.setUint16(12, entry.time, true);
    view.setUint16(14, entry.date, true);
    view.setUint32(16, entry.crc, true);
    view.setUint32(20, entry.size, true);
    view.setUint32(24, entry.size, true);
    view.setUint16(28, entry.nameBytes.length, true);
    view.setUint16(30, 0, true);
    view.setUint16(32, 0, true);
    view.setUint16(34, 0, true);
    view.setUint16(36, 0, true);
    view.setUint32(38, offset, true);
    view.setUint32(42, 0, true);
    return buffer;
  }

  function concatUint8(parts) {
    const total = parts.reduce((sum, part) => sum + part.length, 0);
    const buffer = new Uint8Array(total);
    let offset = 0;
    parts.forEach((part) => {
      buffer.set(part, offset);
      offset += part.length;
    });
    return buffer;
  }

  function Zip(prefix) {
    this.prefix = prefix || '';
    this.files = [];
  }

  Zip.prototype.folder = function folder(name) {
    const clean = sanitize(name).replace(/\/+$/g, '');
    const nextPrefix = this.prefix + (clean ? `${clean}/` : '');
    const folderZip = new Zip(nextPrefix);
    folderZip.files = this.files;
    return folderZip;
  };

  Zip.prototype.file = function file(name, data, options) {
    this.addFile(this.prefix + sanitize(name), data, options);
    return this;
  };

  Zip.prototype.addFile = function addFile(path, data, options) {
    const clean = sanitize(path);
    const payload = (options && options.base64) ? fromBase64(data) : toBytes(data);
    const stamp = dosTime();
    this.files.push({
      name: clean,
      nameBytes: encoder.encode(clean),
      data: payload,
      crc: crc32(payload),
      size: payload.length,
      time: stamp.time,
      date: stamp.date
    });
    return this;
  };

  Zip.prototype.generateAsync = function generateAsync(options) {
    const locals = [];
    const centrals = [];
    let offset = 0;

    this.files.forEach((entry) => {
      const local = createLocalHeader(entry);
      locals.push(local, entry.nameBytes, entry.data);
      const central = createCentralHeader(entry, offset);
      centrals.push(central, entry.nameBytes);
      offset += local.length + entry.nameBytes.length + entry.data.length;
    });

    const centralSize = centrals.reduce((sum, part) => sum + part.length, 0);
    const localSize = locals.reduce((sum, part) => sum + part.length, 0);

    const end = new Uint8Array(22);
    const view = new DataView(end.buffer);
    view.setUint32(0, 0x06054b50, true);
    view.setUint16(4, 0, true);
    view.setUint16(6, 0, true);
    view.setUint16(8, this.files.length, true);
    view.setUint16(10, this.files.length, true);
    view.setUint32(12, centralSize, true);
    view.setUint32(16, localSize, true);
    view.setUint16(20, 0, true);

    const output = concatUint8(locals.concat(centrals, [end]));
    if (options && options.type === 'blob') {
      return Promise.resolve(new Blob([output], { type: 'application/zip' }));
    }
    return Promise.resolve(output);
  };

  window.JSZip = function createZip() {
    return new Zip('');
  };
  window.JSZip.JSZip = Zip;
})();
